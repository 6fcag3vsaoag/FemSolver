#include "../include/ExportManager.h"
#include "../include/EllipticApp.h"
#include "../include/FemSolver.h"  // Include FemSolver.h to define FemSolver class
#include "../include/StringUtils.h"
#include <fstream>
#include <sstream>
#include <iomanip>

// Constructor
ExportManager::ExportManager() : m_solver(nullptr), m_appData(nullptr) {
    m_status = "Export manager initialized";
}

// Destructor
ExportManager::~ExportManager() {
    // Clean up if needed
}

// Initialize with solver and app data
void ExportManager::initialize(FemSolver* solver, AppData* appData) {
    m_solver = solver;
    m_appData = appData;
    m_status = "Export manager initialized with solver and app data";
}

// Export solution data to a file
bool ExportManager::exportSolutionToFile(const std::string& filename) {
    if (!m_solver || !m_appData) {
        m_status = "Solver or AppData not initialized";
        return false;
    }

    try {
        EllipticApp* ellipticApp = m_solver->getApp();
        if (!ellipticApp) {
            m_status = "Failed to access solver application";
            return false;
        }

        // Get the solution and mesh
        const std::vector<double>& solution = ellipticApp->getSolution();
        const Mesh& mesh = ellipticApp->getMesh();

        if (solution.empty()) {
            m_status = "No solution data available to export";
            return false;
        }

        // Open file in binary mode to ensure UTF-8 output without locale interference
        std::ofstream outFile(utf8_to_wstring(filename).c_str(), std::ios_base::binary);
        if (!outFile.is_open()) {
            m_status = "Could not open file for export: " + filename;
            return false;
        }

        // Write UTF-8 BOM
        outFile.write("\xEF\xBB\xBF", 3);

        // Write solution data to file
        outFile << "# Finite Element Solution Data\n";
        outFile << "# Generated by FEM Solver\n";
        outFile << "# Domain: [0, " << m_appData->Lx << "] x [0, " << m_appData->Ly << "]\n";
        outFile << "# Mesh: " << m_appData->Nx << " x " << m_appData->Ny << " nodes\n";
        outFile << "# Coefficients:\n";
        outFile << "#   a11(x,y) = " << m_appData->a11Func << "\n";
        outFile << "#   a12(x,y) = " << m_appData->a12Func << "\n";
        outFile << "#   a22(x,y) = " << m_appData->a22Func << "\n";
        outFile << "#   b1(x,y) = " << m_appData->b1Func << "\n";
        outFile << "#   b2(x,y) = " << m_appData->b2Func << "\n";
        outFile << "#   c(x,y) = " << m_appData->cFunc << "\n";
        outFile << "#   f(x,y) = " << m_appData->fFunc << "\n";
        outFile << "\n";
        outFile << "# Node_ID\tX_coord\tY_coord\tSolution_Value\n";

        // Write node data with solution values
        size_t min_size = (mesh.nodes.size() < solution.size()) ? mesh.nodes.size() : solution.size();
        for (size_t i = 0; i < min_size; ++i) {
            outFile << i << "\t"
                   << mesh.nodes[i].first << "\t"
                   << mesh.nodes[i].second << "\t"
                   << solution[i] << "\n";
        }

        // Write element connectivity
        outFile << "\n# Element Connectivity\n";
        outFile << "# Element_ID\tNode1\tNode2\tNode3\n";
        for (size_t i = 0; i < mesh.elements.size(); ++i) {
            outFile << i << "\t"
                   << mesh.elements[i][0] << "\t"
                   << mesh.elements[i][1] << "\t"
                   << mesh.elements[i][2] << "\n";
        }

        outFile.close();

        m_status = "Results successfully exported to: " + filename;
        return true;
    } catch (const std::exception& e) {
        m_status = std::string("Export error: ") + e.what();
        return false;
    }
}

// Export solution data with current parameters
bool ExportManager::exportCurrentSolution() {
    if (!m_appData) {
        m_status = "AppData not initialized";
        return false;
    }

    // In a real implementation, you might want to use a default filename or get it from the UI
    // For now, we'll return false to indicate this needs to be implemented properly
    m_status = "Current solution export requires user to specify filename";
    return false;
}

// Export solution with specific data
bool ExportManager::exportSolution(const Mesh& mesh, const std::vector<double>& solution, 
                                   int Nx, int Ny, double Lx, double Ly,
                                   const std::string& a11, const std::string& a12, const std::string& a22,
                                   const std::string& b1, const std::string& b2, const std::string& c, const std::string& f,
                                   const std::map<std::string, std::string>& boundaryConditions,
                                   const std::string& title) {
    // This is a simplified implementation - in practice, you'd implement the full export logic here
    m_status = "Solution export with specific parameters not implemented yet";
    return false;
}

// Get export status
std::string ExportManager::getExportStatus() const {
    return m_status;
}